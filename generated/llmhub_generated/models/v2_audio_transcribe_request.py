# coding: utf-8

"""
    llm_hub

    Application-agnostic LLM service with multi-provider support and billing tracking

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class V2AudioTranscribeRequest(BaseModel):
    """
    Transcribe audio to text with audio intelligence features  Supports: - Multi-model transcription (best/nano tiers) - Speaker diarization (who said what) - Sentiment analysis per sentence - Entity detection (names, dates, organizations) - Auto-summarization with chapters - Topic classification (600+ IAB categories) - Content moderation - PII redaction for privacy - Custom vocabulary boosting
    """ # noqa: E501
    provider: Optional[StrictStr] = None
    model: Optional[StrictStr] = None
    max_tokens: Optional[Annotated[int, Field(le=16000, strict=True, ge=100)]] = None
    temperature: Optional[Union[Annotated[float, Field(le=2.0, strict=True, ge=0.0)], Annotated[int, Field(le=2, strict=True, ge=0)]]] = None
    audio_url: StrictStr = Field(description="Public URL to audio file (REQUIRED)")
    language_code: Optional[StrictStr] = None
    speaker_labels: Optional[StrictBool] = None
    speakers_expected: Optional[Annotated[int, Field(le=20, strict=True, ge=1)]] = None
    sentiment_analysis: Optional[StrictBool] = None
    entity_detection: Optional[StrictBool] = None
    auto_chapters: Optional[StrictBool] = None
    summarization: Optional[StrictBool] = None
    summarization_type: Optional[StrictStr] = None
    iab_categories: Optional[StrictBool] = None
    content_safety: Optional[StrictBool] = None
    filter_profanity: Optional[StrictBool] = None
    redact_pii: Optional[StrictBool] = None
    word_boost: Optional[List[StrictStr]] = None
    boost_param: Optional[StrictStr] = None
    detect_language: Optional[StrictBool] = None
    smart_format: Optional[StrictBool] = None
    punctuate: Optional[StrictBool] = None
    paragraphs: Optional[StrictBool] = None
    numerals: Optional[StrictBool] = None
    filler_words: Optional[StrictBool] = None
    utterances: Optional[StrictBool] = None
    topics: Optional[StrictBool] = None
    custom_topics: Optional[List[StrictStr]] = None
    intents: Optional[StrictBool] = None
    keywords: Optional[List[StrictStr]] = None
    keyword_boost: Optional[Union[Annotated[float, Field(le=5.0, strict=True, ge=1.0)], Annotated[int, Field(le=5, strict=True, ge=1)]]] = None
    search: Optional[List[StrictStr]] = None
    replace: Optional[Dict[str, StrictStr]] = None
    multichannel: Optional[StrictBool] = None
    __properties: ClassVar[List[str]] = ["provider", "model", "max_tokens", "temperature", "audio_url", "language_code", "speaker_labels", "speakers_expected", "sentiment_analysis", "entity_detection", "auto_chapters", "summarization", "summarization_type", "iab_categories", "content_safety", "filter_profanity", "redact_pii", "word_boost", "boost_param", "detect_language", "smart_format", "punctuate", "paragraphs", "numerals", "filler_words", "utterances", "topics", "custom_topics", "intents", "keywords", "keyword_boost", "search", "replace", "multichannel"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of V2AudioTranscribeRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if provider (nullable) is None
        # and model_fields_set contains the field
        if self.provider is None and "provider" in self.model_fields_set:
            _dict['provider'] = None

        # set to None if model (nullable) is None
        # and model_fields_set contains the field
        if self.model is None and "model" in self.model_fields_set:
            _dict['model'] = None

        # set to None if max_tokens (nullable) is None
        # and model_fields_set contains the field
        if self.max_tokens is None and "max_tokens" in self.model_fields_set:
            _dict['max_tokens'] = None

        # set to None if temperature (nullable) is None
        # and model_fields_set contains the field
        if self.temperature is None and "temperature" in self.model_fields_set:
            _dict['temperature'] = None

        # set to None if language_code (nullable) is None
        # and model_fields_set contains the field
        if self.language_code is None and "language_code" in self.model_fields_set:
            _dict['language_code'] = None

        # set to None if speaker_labels (nullable) is None
        # and model_fields_set contains the field
        if self.speaker_labels is None and "speaker_labels" in self.model_fields_set:
            _dict['speaker_labels'] = None

        # set to None if speakers_expected (nullable) is None
        # and model_fields_set contains the field
        if self.speakers_expected is None and "speakers_expected" in self.model_fields_set:
            _dict['speakers_expected'] = None

        # set to None if sentiment_analysis (nullable) is None
        # and model_fields_set contains the field
        if self.sentiment_analysis is None and "sentiment_analysis" in self.model_fields_set:
            _dict['sentiment_analysis'] = None

        # set to None if entity_detection (nullable) is None
        # and model_fields_set contains the field
        if self.entity_detection is None and "entity_detection" in self.model_fields_set:
            _dict['entity_detection'] = None

        # set to None if auto_chapters (nullable) is None
        # and model_fields_set contains the field
        if self.auto_chapters is None and "auto_chapters" in self.model_fields_set:
            _dict['auto_chapters'] = None

        # set to None if summarization (nullable) is None
        # and model_fields_set contains the field
        if self.summarization is None and "summarization" in self.model_fields_set:
            _dict['summarization'] = None

        # set to None if summarization_type (nullable) is None
        # and model_fields_set contains the field
        if self.summarization_type is None and "summarization_type" in self.model_fields_set:
            _dict['summarization_type'] = None

        # set to None if iab_categories (nullable) is None
        # and model_fields_set contains the field
        if self.iab_categories is None and "iab_categories" in self.model_fields_set:
            _dict['iab_categories'] = None

        # set to None if content_safety (nullable) is None
        # and model_fields_set contains the field
        if self.content_safety is None and "content_safety" in self.model_fields_set:
            _dict['content_safety'] = None

        # set to None if filter_profanity (nullable) is None
        # and model_fields_set contains the field
        if self.filter_profanity is None and "filter_profanity" in self.model_fields_set:
            _dict['filter_profanity'] = None

        # set to None if redact_pii (nullable) is None
        # and model_fields_set contains the field
        if self.redact_pii is None and "redact_pii" in self.model_fields_set:
            _dict['redact_pii'] = None

        # set to None if word_boost (nullable) is None
        # and model_fields_set contains the field
        if self.word_boost is None and "word_boost" in self.model_fields_set:
            _dict['word_boost'] = None

        # set to None if boost_param (nullable) is None
        # and model_fields_set contains the field
        if self.boost_param is None and "boost_param" in self.model_fields_set:
            _dict['boost_param'] = None

        # set to None if detect_language (nullable) is None
        # and model_fields_set contains the field
        if self.detect_language is None and "detect_language" in self.model_fields_set:
            _dict['detect_language'] = None

        # set to None if smart_format (nullable) is None
        # and model_fields_set contains the field
        if self.smart_format is None and "smart_format" in self.model_fields_set:
            _dict['smart_format'] = None

        # set to None if punctuate (nullable) is None
        # and model_fields_set contains the field
        if self.punctuate is None and "punctuate" in self.model_fields_set:
            _dict['punctuate'] = None

        # set to None if paragraphs (nullable) is None
        # and model_fields_set contains the field
        if self.paragraphs is None and "paragraphs" in self.model_fields_set:
            _dict['paragraphs'] = None

        # set to None if numerals (nullable) is None
        # and model_fields_set contains the field
        if self.numerals is None and "numerals" in self.model_fields_set:
            _dict['numerals'] = None

        # set to None if filler_words (nullable) is None
        # and model_fields_set contains the field
        if self.filler_words is None and "filler_words" in self.model_fields_set:
            _dict['filler_words'] = None

        # set to None if utterances (nullable) is None
        # and model_fields_set contains the field
        if self.utterances is None and "utterances" in self.model_fields_set:
            _dict['utterances'] = None

        # set to None if topics (nullable) is None
        # and model_fields_set contains the field
        if self.topics is None and "topics" in self.model_fields_set:
            _dict['topics'] = None

        # set to None if custom_topics (nullable) is None
        # and model_fields_set contains the field
        if self.custom_topics is None and "custom_topics" in self.model_fields_set:
            _dict['custom_topics'] = None

        # set to None if intents (nullable) is None
        # and model_fields_set contains the field
        if self.intents is None and "intents" in self.model_fields_set:
            _dict['intents'] = None

        # set to None if keywords (nullable) is None
        # and model_fields_set contains the field
        if self.keywords is None and "keywords" in self.model_fields_set:
            _dict['keywords'] = None

        # set to None if keyword_boost (nullable) is None
        # and model_fields_set contains the field
        if self.keyword_boost is None and "keyword_boost" in self.model_fields_set:
            _dict['keyword_boost'] = None

        # set to None if search (nullable) is None
        # and model_fields_set contains the field
        if self.search is None and "search" in self.model_fields_set:
            _dict['search'] = None

        # set to None if replace (nullable) is None
        # and model_fields_set contains the field
        if self.replace is None and "replace" in self.model_fields_set:
            _dict['replace'] = None

        # set to None if multichannel (nullable) is None
        # and model_fields_set contains the field
        if self.multichannel is None and "multichannel" in self.model_fields_set:
            _dict['multichannel'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of V2AudioTranscribeRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "provider": obj.get("provider"),
            "model": obj.get("model"),
            "max_tokens": obj.get("max_tokens"),
            "temperature": obj.get("temperature"),
            "audio_url": obj.get("audio_url"),
            "language_code": obj.get("language_code"),
            "speaker_labels": obj.get("speaker_labels"),
            "speakers_expected": obj.get("speakers_expected"),
            "sentiment_analysis": obj.get("sentiment_analysis"),
            "entity_detection": obj.get("entity_detection"),
            "auto_chapters": obj.get("auto_chapters"),
            "summarization": obj.get("summarization"),
            "summarization_type": obj.get("summarization_type"),
            "iab_categories": obj.get("iab_categories"),
            "content_safety": obj.get("content_safety"),
            "filter_profanity": obj.get("filter_profanity"),
            "redact_pii": obj.get("redact_pii"),
            "word_boost": obj.get("word_boost"),
            "boost_param": obj.get("boost_param"),
            "detect_language": obj.get("detect_language"),
            "smart_format": obj.get("smart_format"),
            "punctuate": obj.get("punctuate"),
            "paragraphs": obj.get("paragraphs"),
            "numerals": obj.get("numerals"),
            "filler_words": obj.get("filler_words"),
            "utterances": obj.get("utterances"),
            "topics": obj.get("topics"),
            "custom_topics": obj.get("custom_topics"),
            "intents": obj.get("intents"),
            "keywords": obj.get("keywords"),
            "keyword_boost": obj.get("keyword_boost"),
            "search": obj.get("search"),
            "replace": obj.get("replace"),
            "multichannel": obj.get("multichannel")
        })
        return _obj


